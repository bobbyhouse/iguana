package main

import (
	"context"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"

	"iguana/internal/evidence"
	"iguana/internal/export"
	"iguana/internal/model"
)

// command describes a CLI subcommand.
type command struct {
	name  string
	short string // one-line summary for help listing
	usage string // usage line, e.g. "iguana analyze <dir-or-file>"
	long  string // multi-line description shown by "iguana help <cmd>"
	run   func(args []string) error
}

// commands is the single source of truth for all registered subcommands
// (invariant 38). Dispatch, help listing, and "iguana help <cmd>" all
// derive from this slice.
var commands = []command{
	{
		name:  "analyze",
		short: "Generate evidence bundles from Go source files",
		usage: "iguana analyze <dir-or-file>",
		long: `Generate evidence bundles from Go source files.

When given a directory, walks all .go files (excluding test files,
vendor/, testdata/, examples/, docs/) and writes companion
<file>.evidence.yaml bundles.

When given a single .go file, writes one <file>.evidence.yaml bundle.
`,
		run: runAnalyze,
	},
	{
		name:  "system-model",
		short: "Aggregate evidence bundles into a system model",
		usage: "iguana system-model <dir> [output.yaml]",
		long: `Aggregate evidence bundles in <dir> into a system model YAML.

Reads all *.evidence.yaml files under <dir>, infers state domains,
effects, and trust zones, and writes the result to output.yaml
(default: <dir>/system_model.yaml).
`,
		run: runSystemModel,
	},
	{
		name:  "obsidian-vault",
		short: "Convert system model to an Obsidian vault",
		usage: "iguana obsidian-vault <model.yaml> [output-dir]",
		long: `Convert a system model YAML into an Obsidian-compatible vault.

Reads <model.yaml> and writes Markdown files into [output-dir]
(default: a directory named after the model file, without the extension).
`,
		run: runObsidianVault,
	},
	{
		name:  "clean",
		short: "Remove generated *.evidence.yaml files",
		usage: "iguana clean [dir]",
		long: `Remove all *.evidence.yaml files generated by iguana analyze.

Walks [dir] (default: current directory) and deletes every file
matching *.evidence.yaml.
`,
		run: runClean,
	},
}

// printUsage writes the overall help listing to w.
func printUsage(w io.Writer) {
	fmt.Fprintf(w, "iguana â€” Go codebase static analysis tool\n\n")
	fmt.Fprintf(w, "Usage:\n  iguana <command> [arguments]\n\n")
	fmt.Fprintf(w, "Commands:\n")
	for _, cmd := range commands {
		fmt.Fprintf(w, "  %-16s %s\n", cmd.name, cmd.short)
	}
	fmt.Fprintf(w, "\nRun 'iguana help <command>' for details on a specific command.\n")
}

// printCommandHelp writes the long help for the named command to w.
// If the name is unknown, it writes an error message.
func printCommandHelp(w io.Writer, name string) {
	for _, cmd := range commands {
		if cmd.name == name {
			fmt.Fprintf(w, "Usage: %s\n\n%s", cmd.usage, cmd.long)
			return
		}
	}
	fmt.Fprintf(w, "iguana: unknown command %q\n\nRun 'iguana help' for usage.\n", name)
}

// dispatch is the core dispatch function, separated from main() to allow testing.
// args is os.Args[1:].
func dispatch(args []string) error {
	if len(args) == 0 || args[0] == "--help" || args[0] == "-h" {
		printUsage(os.Stdout)
		return nil
	}

	// "iguana help" or "iguana help <cmd>"
	if args[0] == "help" {
		if len(args) >= 2 {
			printCommandHelp(os.Stdout, args[1])
		} else {
			printUsage(os.Stdout)
		}
		return nil
	}

	// Known subcommand?
	for _, cmd := range commands {
		if cmd.name == args[0] {
			return cmd.run(args[1:])
		}
	}

	// Unknown first arg: if it names an existing file or directory, fall
	// through to the legacy file/dir handler (backward compat, invariant 35).
	if _, err := os.Stat(args[0]); err == nil {
		return legacyFilePath(args[0], false)
	}

	// Unknown and not a file/dir: helpful error (invariant 34).
	return fmt.Errorf("unknown command %q\n\nRun 'iguana help' for usage.", args[0])
}

// runAnalyze implements the "analyze" subcommand.
func runAnalyze(args []string) error {
	force, rest := parseForceFlag(args)
	if len(rest) < 1 {
		return fmt.Errorf("usage: iguana analyze [--force] <dir-or-file>")
	}
	return legacyFilePath(rest[0], force)
}

// legacyFilePath contains the original file/dir dispatch logic.
func legacyFilePath(filePath string, force bool) error {
	// Directory mode: walk all .go files under the root.
	if info, err := os.Stat(filePath); err == nil && info.IsDir() {
		written, skipped, errs := evidence.WalkAndGenerate(filePath, force)
		for _, e := range errs {
			fmt.Fprintf(os.Stderr, "error: %v\n", e)
		}
		fmt.Printf("wrote %d, skipped %d (up to date), %d errors\n", written, skipped, len(errs))
		if len(errs) > 0 {
			return fmt.Errorf("%d errors during analysis", len(errs))
		}
		return nil
	}

	if strings.HasSuffix(filePath, ".go") {
		bundle, err := evidence.CreateEvidenceBundle(filePath)
		if err != nil {
			return err
		}
		skipped, err := evidence.WriteEvidenceBundle(bundle, force)
		if err != nil {
			return err
		}
		if skipped {
			fmt.Printf("up to date %s.evidence.yaml\n", filePath)
		} else {
			fmt.Printf("wrote %s.evidence.yaml\n", filePath)
		}
		return nil
	}

	return fmt.Errorf("not a .go file or directory: %s", filePath)
}

// runSystemModel implements the "system-model" subcommand.
func runSystemModel(args []string) error {
	force, rest := parseForceFlag(args)
	if len(rest) < 1 {
		return fmt.Errorf("usage: iguana system-model [--force] <dir> [output.yaml]")
	}
	root := rest[0]
	outputPath := filepath.Join(root, "system_model.yaml")
	if len(rest) >= 2 {
		outputPath = rest[1]
	}
	if !force {
		upToDate, err := model.SystemModelUpToDate(root, outputPath)
		if err != nil {
			return fmt.Errorf("check up-to-date: %w", err)
		}
		if upToDate {
			fmt.Printf("system model up to date: %s\n", outputPath)
			return nil
		}
	}
	m, err := model.GenerateSystemModel(context.Background(), root)
	if err != nil {
		return err
	}
	if err := model.WriteSystemModel(m, outputPath); err != nil {
		return err
	}
	fmt.Printf("wrote %s (%d state domains, %d effects)\n",
		outputPath, len(m.StateDomains), len(m.Effects))
	return nil
}

// parseForceFlag extracts --force / -f from args, returning the flag value
// and the remaining args with the flag removed.
func parseForceFlag(args []string) (force bool, rest []string) {
	for _, a := range args {
		if a == "--force" || a == "-f" {
			force = true
		} else {
			rest = append(rest, a)
		}
	}
	return
}

// runObsidianVault implements the "obsidian-vault" subcommand.
func runObsidianVault(args []string) error {
	if len(args) < 1 {
		return fmt.Errorf("usage: iguana obsidian-vault <model.yaml> [output-dir]")
	}
	modelPath := args[0]
	outputDir := "obsidian-vault"
	if len(args) >= 2 {
		outputDir = args[1]
	}
	m, err := model.ReadSystemModel(modelPath)
	if err != nil {
		return err
	}
	bundle, err := export.GenerateKnowledgeBundle(m)
	if err != nil {
		return err
	}
	if err := export.WriteKnowledgeBundle(bundle, outputDir); err != nil {
		return err
	}
	fmt.Printf("wrote knowledge bundle to %s\n", outputDir)
	return nil
}

// runClean implements the "clean" subcommand.
func runClean(args []string) error {
	root := "."
	if len(args) >= 1 {
		root = args[0]
	}
	removed, err := evidence.CleanEvidenceBundles(root)
	if err != nil {
		return err
	}
	fmt.Printf("removed %d evidence file(s)\n", removed)
	return nil
}

func main() {
	if err := dispatch(os.Args[1:]); err != nil {
		log.Fatal(err)
	}
}
