package main

import (
	b "iguana/baml_client"
	"iguana/baml_client/types"
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"
)

// command describes a CLI subcommand.
type command struct {
	name  string
	short string // one-line summary for help listing
	usage string // usage line, e.g. "iguana analyze <dir-or-file>"
	long  string // multi-line description shown by "iguana help <cmd>"
	run   func(args []string) error
}

// commands is the single source of truth for all registered subcommands
// (invariant 38). Dispatch, help listing, and "iguana help <cmd>" all
// derive from this slice.
var commands = []command{
	{
		name:  "analyze",
		short: "Generate evidence bundles from Go source files",
		usage: "iguana analyze <dir-or-file>",
		long: `Generate evidence bundles from Go source files.

When given a directory, walks all .go files (excluding test files,
vendor/, testdata/, examples/, docs/) and writes companion
<file>.evidence.yaml bundles.

When given a single .go file, writes one <file>.evidence.yaml bundle.
`,
		run: runAnalyze,
	},
	{
		name:  "system-model",
		short: "Aggregate evidence bundles into a system model",
		usage: "iguana system-model <dir> [output.yaml]",
		long: `Aggregate evidence bundles in <dir> into a system model YAML.

Reads all *.evidence.yaml files under <dir>, infers state domains,
effects, and trust zones, and writes the result to output.yaml
(default: <dir>/system_model.yaml).
`,
		run: runSystemModel,
	},
	{
		name:  "obsidian-vault",
		short: "Convert system model to an Obsidian vault",
		usage: "iguana obsidian-vault <model.yaml> [output-dir]",
		long: `Convert a system model YAML into an Obsidian-compatible vault.

Reads <model.yaml> and writes Markdown files into [output-dir]
(default: a directory named after the model file, without the extension).
`,
		run: runObsidianVault,
	},
	{
		name:  "clean",
		short: "Remove generated *.evidence.yaml files",
		usage: "iguana clean [dir]",
		long: `Remove all *.evidence.yaml files generated by iguana analyze.

Walks [dir] (default: current directory) and deletes every file
matching *.evidence.yaml.
`,
		run: runClean,
	},
}

// printUsage writes the overall help listing to w.
func printUsage(w io.Writer) {
	fmt.Fprintf(w, "iguana — Go codebase static analysis tool\n\n")
	fmt.Fprintf(w, "Usage:\n  iguana <command> [arguments]\n\n")
	fmt.Fprintf(w, "Commands:\n")
	for _, cmd := range commands {
		fmt.Fprintf(w, "  %-16s %s\n", cmd.name, cmd.short)
	}
	fmt.Fprintf(w, "\nRun 'iguana help <command>' for details on a specific command.\n")
}

// printCommandHelp writes the long help for the named command to w.
// If the name is unknown, it writes an error message.
func printCommandHelp(w io.Writer, name string) {
	for _, cmd := range commands {
		if cmd.name == name {
			fmt.Fprintf(w, "Usage: %s\n\n%s", cmd.usage, cmd.long)
			return
		}
	}
	fmt.Fprintf(w, "iguana: unknown command %q\n\nRun 'iguana help' for usage.\n", name)
}

// dispatch is the core dispatch function, separated from main() to allow testing.
// args is os.Args[1:].
func dispatch(args []string) error {
	if len(args) == 0 || args[0] == "--help" || args[0] == "-h" {
		printUsage(os.Stdout)
		return nil
	}

	// "iguana help" or "iguana help <cmd>"
	if args[0] == "help" {
		if len(args) >= 2 {
			printCommandHelp(os.Stdout, args[1])
		} else {
			printUsage(os.Stdout)
		}
		return nil
	}

	// Known subcommand?
	for _, cmd := range commands {
		if cmd.name == args[0] {
			return cmd.run(args[1:])
		}
	}

	// Unknown first arg: if it names an existing file or directory, fall
	// through to the legacy file/dir handler (backward compat, invariant 35).
	if _, err := os.Stat(args[0]); err == nil {
		return legacyFilePath(args[0])
	}

	// Unknown and not a file/dir: helpful error (invariant 34).
	return fmt.Errorf("unknown command %q\n\nRun 'iguana help' for usage.", args[0])
}

// runAnalyze implements the "analyze" subcommand.
func runAnalyze(args []string) error {
	if len(args) < 1 {
		return fmt.Errorf("usage: iguana analyze <dir-or-file>")
	}
	return legacyFilePath(args[0])
}

// legacyFilePath contains the original file/dir dispatch logic.
func legacyFilePath(filePath string) error {
	// Directory mode: walk all .go files under the root.
	if info, err := os.Stat(filePath); err == nil && info.IsDir() {
		written, errs := walkAndGenerate(filePath)
		for _, e := range errs {
			fmt.Fprintf(os.Stderr, "error: %v\n", e)
		}
		fmt.Printf("wrote %d bundles, %d errors\n", written, len(errs))
		if len(errs) > 0 {
			return fmt.Errorf("%d errors during analysis", len(errs))
		}
		return nil
	}

	if strings.HasSuffix(filePath, ".go") {
		// v2: semantic analysis — writes companion .evidence.yaml file.
		bundle, err := createEvidenceBundleV2(filePath)
		if err != nil {
			return err
		}
		if err := writeEvidenceBundleV2(bundle); err != nil {
			return err
		}
		fmt.Printf("wrote %s.evidence.yaml\n", filePath)
		return nil
	}

	// v1: integrity only — prints to stdout.
	evidence, err := createEvidenceBundle(filePath)
	if err != nil {
		return err
	}
	out, err := yaml.Marshal(evidence)
	if err != nil {
		return err
	}
	fmt.Print(string(out))
	return nil
}

// runSystemModel implements the "system-model" subcommand.
func runSystemModel(args []string) error {
	if len(args) < 1 {
		return fmt.Errorf("usage: iguana system-model <dir> [output.yaml]")
	}
	root := args[0]
	outputPath := filepath.Join(root, "system_model.yaml")
	if len(args) >= 2 {
		outputPath = args[1]
	}
	model, err := GenerateSystemModel(context.Background(), root)
	if err != nil {
		return err
	}
	if err := WriteSystemModel(model, outputPath); err != nil {
		return err
	}
	fmt.Printf("wrote %s (%d state domains, %d effects)\n",
		outputPath, len(model.StateDomains), len(model.Effects))
	return nil
}

// runObsidianVault implements the "obsidian-vault" subcommand.
func runObsidianVault(args []string) error {
	if len(args) < 1 {
		return fmt.Errorf("usage: iguana obsidian-vault <model.yaml> [output-dir]")
	}
	// obsidian-vault functionality is not yet implemented.
	return fmt.Errorf("obsidian-vault: not yet implemented")
}

// runClean implements the "clean" subcommand.
func runClean(args []string) error {
	dir := "."
	if len(args) >= 1 {
		dir = args[0]
	}
	var removed int
	err := filepath.WalkDir(dir, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() && strings.HasSuffix(path, ".evidence.yaml") {
			if removeErr := os.Remove(path); removeErr != nil {
				return removeErr
			}
			removed++
		}
		return nil
	})
	if err != nil {
		return err
	}
	fmt.Printf("removed %d evidence file(s)\n", removed)
	return nil
}

// categorizeFile reads a file and determines its state type.
func categorizeFile(filePath string) (types.State, error) {
	content, err := os.ReadFile(filePath)
	if err != nil {
		return "", err
	}

	ctx := context.Background()
	return b.TypeOfState(ctx, string(content))
}

type EvidenceBundle struct {
	Version int      `yaml:"version"`
	File    FileMeta `yaml:"file"`
}

type FileMeta struct {
	Path   string `yaml:"path"`
	SHA256 string `yaml:"sha256"`
}

func createEvidenceBundle(filePath string) (EvidenceBundle, error) {
	b, err := os.ReadFile(filePath)
	if err != nil {
		return EvidenceBundle{}, err
	}

	sum := sha256.Sum256(b)
	return EvidenceBundle{
		Version: 1,
		File: FileMeta{
			Path:   filePath,
			SHA256: hex.EncodeToString(sum[:]),
		},
	}, nil
}

func main() {
	if err := dispatch(os.Args[1:]); err != nil {
		log.Fatal(err)
	}
}
